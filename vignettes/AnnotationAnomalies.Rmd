---
title: "Detection of Annotation Anomalies"
author:
    - name: Anthony Christidis
      affiliation:
        - &core_affiliation Core for Computational Biomedicine, Harvard Medical School
    - name: Andrew Ghazi
      affiliation:
        - *core_affiliation
    - name: Smriti Chawla
      affiliation:
        - *core_affiliation
    - name: Nitesh Turaga
      affiliation:
        - *core_affiliation
    - name: Ludwig Geistlinger
      affiliation:
        - *core_affiliation
    - name: Robert Gentleman
      affiliation:
        - *core_affiliation
package: scDiagnostics
output: 
  BiocStyle::html_document:
    toc: true
    toc_float: true
vignette: >
  %\VignetteIndexEntry{6. Detection of Annotation Anomalies}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include = FALSE, fig.show='hide'}
knitr::knit_hooks$set(pngquant = knitr::hook_pngquant)

knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
dev = "ragg_png",
dpi = 72,
fig.retina = 2,
fig.align = "center",
out.width = "100%",
pngquant = "--speed=1 --quality=1-5"
)
```

# Introduction 

The `scDiagnostics` package provides powerful tools for anomaly detection in single-cell data, enabling researchers to identify and analyze outliers in complex datasets. Central to this process is the `detectAnomaly()` function, which integrates dimensionality reduction through Principal Component Analysis (PCA) with the robust capabilities of the isolation forest algorithm.

In single-cell analysis, detecting anomalies is crucial for identifying potential data issues, such as mislabeled cells, technical artifacts, or biologically distinct subpopulations. The `detectAnomaly()` function offers a versatile approach to anomaly detection by allowing users to project data onto a PCA space and apply isolation forests to uncover outliers. Whether working solely with a reference dataset or comparing a query dataset against a well-characterized reference, this function provides detailed insights into potential anomalies.

This vignette illustrates how to effectively use the `detectAnomaly()` function in various scenarios. We explore both cell-type-specific and global anomaly detection, demonstrate the utility of integrating query data with reference data, and offer guidance on interpreting the results. Additionally, we show how to extend this analysis by combining anomaly detection with PCA loadings using the `calculateCellSimilarityPCA()` function, providing a comprehensive toolkit for investigating the structure and quality of single-cell data.

Whether you're looking to enhance the accuracy of your cell type annotations or identify subtle deviations in your data, the tools provided by `scDiagnostics` will empower you to conduct thorough and nuanced assessments of your single-cell datasets.

# Preliminaries

In the context of the `scDiagnostics` package, the following datasets illustrate the application of these tools:

- `reference_data`: A curated and processed dataset containing expert-assigned cell type annotations. This dataset serves as a reference for comparison and can be used alone to detect anomalies within the reference annotations.

- `query_data`: A dataset that also includes expert-assigned cell type annotations, but additionally features annotations generated by the `r BiocStyle::Biocpkg("SingleR")` package. This allows for the comparison of expert annotations with those produced by an automated method to detect inconsistencies or anomalies.

```{r, message=FALSE, fig.show='hide'}
# Load library
library(scDiagnostics)

# Load datasets
data("reference_data")
data("query_data")

# Set seed for reproducibility
set.seed(0)
```


By using these datasets, you can leverage the package's tools to compare annotations between `reference_data` and `query_data`, or analyze `reference_data` alone to identify potential issues. The packageâ€™s flexibility supports various analysis scenarios, whether you need to assess overall annotation quality or focus on specific cell types.

Through these capabilities, `scDiagnostics` empowers you to perform thorough and nuanced assessments of cell type annotations, enhancing the accuracy and reliability of your analyses.


# The `detectAnomaly()` Function 

## Function Overview  

### Description

The `detectAnomaly()` function integrates dimensionality reduction via PCA with the isolation forest algorithm to detect anomalies in single-cell data. By projecting both reference and query datasets (if available) onto the PCA space of the reference data, the function trains an isolation forest model on reference data in PCA space to pinpoint anomalies in the reference or query data. This approach is highly versatile:

- **Reference Only**: Compute anomaly scores solely for the reference dataset to identify potential issues within the reference itself.
- **Reference and Query**: Compare the query dataset against the reference to find anomalies in the query data that may not align with the established reference.
- **Global and Specific Analysis**: Assess anomalies at a global level or focus on specific cell types to gain targeted insights into your data.
The function also provides detailed visualizations and statistical outputs to help you interpret the anomalies detected.

### Parameters

The function takes a `SingleCellExperiment` object as `reference_data` and trains an isolation forest model on the reference PCA-projected data, with an optional `query_data` for projecting onto this PCA space for anomaly detection. You can specify cell type annotations through `ref_cell_type_col` and `query_cell_type_col`, and limit the analysis to certain cell types using the `cell_types` parameter. The function allows you to select specific principal components to use to train the isolation forest via `pc_subset`, adjust the number of trees with `n_tree`, and set an `anomaly_threshold` for classifying anomalies.


### Return Value

The function returns several outputs: `anomaly_scores` indicating the likelihood of each cell being an anomaly, a logical vector (`anomaly`) identifying these anomalies, PCA projections for the reference data (`reference_mat_subset`) and optionally for the query data (`query_mat_subset`), and the proportion of variance explained by the selected principal components (`var_explained`).



## `detectAnomaly()` Examples

### Anomaly Detection with Reference and Query Data

This section demonstrates how to use the `detectAnomaly()` function when both reference and query datasets are provided. It includes examples of analyzing anomalies for specific cell types and globally across all data.


#### Example 1: Cell-Type Specific Anomaly Detection
In this example, we analyze anomalies specifically for the "CD4" cell type. The anomaly scores are trained on the PCA projections of the "CD4" cells from the reference dataset. If query data is provided, anomaly scores for the query data are predicted based on the PCA projections of the query data onto the reference PCA space for the "CD4" cell type.




```{r, fig.height=5, fig.width=10, fig.show='hide'}
# Perform anomaly detection
anomaly_output <- detectAnomaly(reference_data = reference_data, 
                                query_data = query_data, 
                                ref_cell_type_col = "expert_annotation", 
                                query_cell_type_col = "SingleR_annotation",
                                pc_subset = 1:5,
                                n_tree = 500,
                                anomaly_treshold = 0.6)

# Plot the output for the "CD4" cell type
plot(anomaly_output, 
     cell_type = "CD4", 
     pc_subset = 1:5, 
     data_type = "query")
```
![](https://raw.githubusercontent.com/ccb-hms/scDiagnostics/main/inst/extdata/compressed/AnnotationAnomalies/detectAnomaly1.png)

In this example, we analyze anomalies specifically for the "CD4" cell type. The anomaly scores are trained on the PCA projections of the "CD4" cells from the reference dataset. If query data is provided, anomaly scores for the query data are predicted based on the PCA projections of the query data onto the reference PCA space for the "CD4" cell type.


#### Example 2: Global Anomaly Detection
Here, we perform global anomaly detection by setting `cell_type = NULL`. In this case, the isolation forest is trained on PCA projections of all cells in the reference data combined. The global anomaly scores are then computed for both reference and query datasets.

```{r, fig.height=5, fig.width=10, fig.show='hide'}
# Perform anomaly detection
anomaly_output <- detectAnomaly(reference_data = reference_data, 
                                query_data = query_data, 
                                ref_cell_type_col = "expert_annotation", 
                                query_cell_type_col = "SingleR_annotation",
                                pc_subset = 1:5,
                                n_tree = 500,
                                anomaly_treshold = 0.6)

# Plot the global anomaly scores
plot(anomaly_output, 
     cell_type = NULL,  # Plot all cell types
     pc_subset = 1:5, 
     data_type = "query")
```
![](https://raw.githubusercontent.com/ccb-hms/scDiagnostics/main/inst/extdata/compressed/AnnotationAnomalies/detectAnomaly2.png)

Setting `cell_type = NULL` means that the anomaly detection is done globally. The isolation forest is trained on PCA projections of all cells from the reference dataset. Anomaly scores are then predicted for the query data based on these global PCA projections. The plot provides a comprehensive view of anomalies across all cell types in the query dataset.

#### Anomaly Detection on Reference Data

Note that if you do not provide a query dataset to the `detectAnomaly()` function, the function will only return the anomaly output data on the reference data.


# Integrating Anomaly Detection with Cell Similarity Analysis Using PCA Loadings

The `detectAnomaly()` function identifies anomalous cells in a dataset by detecting outliers based on PCA results. Once anomalies are detected, `calculateCellSimilarityPCA()` evaluates how these outliers influence principal component directions. This analysis helps determine if anomalous cells significantly impact later PCs, which capture finer variations in the data. By combining these functions, you can both pinpoint anomalies and understand their effect on PCA directions, providing deeper insights into the data structure.
```{r, fig.height=5, fig.width=10, fig.show='hide'}
# Detect anomalies and select top anomalies for further analysis
anomaly_output <- detectAnomaly(reference_data = reference_data, 
                                query_data = query_data,
                                ref_cell_type_col = "expert_annotation", 
                                query_cell_type_col = "SingleR_annotation",
                                pc_subset = 1:10,
                                n_tree = 500,
                                anomaly_treshold = 0.5)

# Select the top 6 anomalies based on the anomaly scores
top6_anomalies <- names(sort(anomaly_output$Combined$reference_anomaly_scores, 
                             decreasing = TRUE)[1:6])

# Calculate cosine similarity between the top anomalies and top 25 PCs
cosine_similarities <- calculateCellSimilarityPCA(reference_data, 
                                                  cell_names = top6_anomalies, 
                                                  pc_subset = 1:25, 
                                                  n_top_vars = 50)

# Plot the cosine similarities across PCs
round(cosine_similarities[, paste0("PC", 15:25)], 2)
```

Note that there is also a plot method for the object return for `calculateCellSimilarityPCA()`. See reference manual for details.

# Conclusion 

This vignette section provides a comprehensive overview of how to use the `detectAnomaly()` function for both reference and query datasets, with specific and global anomaly detection examples, along with how to visualize the results using the plot method. With `calculateCellSimilarityPCA()`, we can assess whether cells have a large effect on the loadings of PC vectors, affecting the downstream analysis.

------------------------------------------------------------------------

# R Session Info

```{r SessionInfo, echo=FALSE, message=FALSE, warning=FALSE, comment=NA, fig.show='hide'}
options(width = 80) 
sessionInfo()
```
